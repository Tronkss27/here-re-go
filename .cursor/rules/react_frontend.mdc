# Frontend React SPOrTS

## **Architettura React**

### **Principi Fondamentali**
- **Componenti funzionali** con hooks
- **TypeScript** per type safety
- **Tailwind CSS** per styling
- **React Query** per data fetching
- **React Hook Form** per form management
- **React Router** per routing

### **Struttura Componenti**

#### **Component Structure**
```typescript
// ✅ DO: Struttura componente standard
import React from 'react'
import { useQuery } from '@tanstack/react-query'
import { Button } from '@/components/ui/button'
import { cn } from '@/utils/cn'
import type { Venue } from '@/types'

interface VenueCardProps {
  venue: Venue
  onSelect?: (venue: Venue) => void
  className?: string
}

export const VenueCard: React.FC<VenueCardProps> = ({
  venue,
  onSelect,
  className
}) => {
  const handleClick = () => {
    onSelect?.(venue)
  }

  return (
    <div className={cn('venue-card', className)} onClick={handleClick}>
      <img src={venue.mainImage} alt={venue.name} />
      <h3>{venue.name}</h3>
      <p>{venue.description}</p>
    </div>
  )
}
```

#### **Custom Hooks**
```typescript
// ✅ DO: Custom hooks per logica riutilizzabile
import { useState, useEffect } from 'react'
import { useQuery } from '@tanstack/react-query'
import { venuesService } from '@/services/venuesService'

export const useVenues = (filters?: VenueFilters) => {
  return useQuery({
    queryKey: ['venues', filters],
    queryFn: () => venuesService.getVenues(filters),
    staleTime: 5 * 60 * 1000, // 5 minuti
    cacheTime: 10 * 60 * 1000 // 10 minuti
  })
}

export const useVenue = (id: string) => {
  return useQuery({
    queryKey: ['venue', id],
    queryFn: () => venuesService.getVenue(id),
    enabled: !!id
  })
}
```

## **Data Fetching**

### **React Query Setup**
```typescript
// ✅ DO: Configurazione React Query
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minuti
      cacheTime: 10 * 60 * 1000, // 10 minuti
      retry: 3,
      refetchOnWindowFocus: false
    },
    mutations: {
      retry: 1
    }
  }
})

export const App = () => {
  return (
    <QueryClientProvider client={queryClient}>
      <Router>
        <Routes>
          {/* routes */}
        </Routes>
      </Router>
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}
```

### **API Services**
```typescript
// ✅ DO: Service layer per API calls
import axios from 'axios'
import type { Venue, CreateVenueData } from '@/types'

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3001/api',
  headers: {
    'Content-Type': 'application/json'
  }
})

// Interceptor per tenant ID
api.interceptors.request.use((config) => {
  const tenantId = localStorage.getItem('tenantId')
  if (tenantId) {
    config.headers['X-Tenant-ID'] = tenantId
  }
  return config
})

// Interceptor per error handling
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export const venuesService = {
  getVenues: async (filters?: VenueFilters): Promise<Venue[]> => {
    const { data } = await api.get('/venues', { params: filters })
    return data.data
  },
  
  getVenue: async (id: string): Promise<Venue> => {
    const { data } = await api.get(`/venues/${id}`)
    return data.data
  },
  
  createVenue: async (venueData: CreateVenueData): Promise<Venue> => {
    const { data } = await api.post('/venues', venueData)
    return data.data
  },
  
  updateVenue: async (id: string, venueData: Partial<Venue>): Promise<Venue> => {
    const { data } = await api.put(`/venues/${id}`, venueData)
    return data.data
  },
  
  deleteVenue: async (id: string): Promise<void> => {
    await api.delete(`/venues/${id}`)
  }
}
```

## **Form Management**

### **React Hook Form**
```typescript
// ✅ DO: Form con React Hook Form e Zod
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'

const venueSchema = z.object({
  name: z.string().min(2, 'Nome deve essere almeno 2 caratteri'),
  email: z.string().email('Email non valida'),
  phone: z.string().optional(),
  address: z.object({
    street: z.string().min(1, 'Indirizzo richiesto'),
    city: z.string().min(1, 'Città richiesta'),
    postalCode: z.string().min(1, 'CAP richiesto')
  })
})

type VenueFormData = z.infer<typeof venueSchema>

export const VenueForm: React.FC<{ onSubmit: (data: VenueFormData) => void }> = ({ onSubmit }) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting }
  } = useForm<VenueFormData>({
    resolver: zodResolver(venueSchema)
  })

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div>
        <Input
          {...register('name')}
          placeholder="Nome locale"
          className={errors.name ? 'border-red-500' : ''}
        />
        {errors.name && (
          <p className="text-red-500 text-sm">{errors.name.message}</p>
        )}
      </div>
      
      <div>
        <Input
          {...register('email')}
          type="email"
          placeholder="Email"
          className={errors.email ? 'border-red-500' : ''}
        />
        {errors.email && (
          <p className="text-red-500 text-sm">{errors.email.message}</p>
        )}
      </div>
      
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Salvando...' : 'Salva'}
      </Button>
    </form>
  )
}
```

## **Routing**

### **React Router Setup**
```typescript
// ✅ DO: Configurazione routing con lazy loading
import { lazy, Suspense } from 'react'
import { BrowserRouter, Routes, Route } from 'react-router-dom'
import { PageLoader } from '@/components/ui/PageLoader'

// Lazy loading per performance
const Home = lazy(() => import('@/pages/Home'))
const Venues = lazy(() => import('@/pages/Venues'))
const VenueDetail = lazy(() => import('@/pages/VenueDetail'))
const AdminLayout = lazy(() => import('@/pages/admin/AdminLayout'))

export const AppRouter = () => {
  return (
    <BrowserRouter>
      <Suspense fallback={<PageLoader />}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/venues" element={<Venues />} />
          <Route path="/venues/:id" element={<VenueDetail />} />
          <Route path="/admin/*" element={<AdminLayout />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  )
}
```

### **Protected Routes**
```typescript
// ✅ DO: Route protette con autenticazione
import { Navigate, useLocation } from 'react-router-dom'
import { useAuth } from '@/hooks/useAuth'

interface ProtectedRouteProps {
  children: React.ReactNode
  requiredRole?: string
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
  children,
  requiredRole
}) => {
  const { user, isLoading } = useAuth()
  const location = useLocation()

  if (isLoading) {
    return <PageLoader />
  }

  if (!user) {
    return <Navigate to="/login" state={{ from: location }} replace />
  }

  if (requiredRole && user.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />
  }

  return <>{children}</>
}
```

## **State Management**

### **Context API**
```typescript
// ✅ DO: Context per stato globale
import { createContext, useContext, useReducer, ReactNode } from 'react'

interface AuthState {
  user: User | null
  token: string | null
  isLoading: boolean
}

type AuthAction =
  | { type: 'LOGIN_START' }
  | { type: 'LOGIN_SUCCESS'; payload: { user: User; token: string } }
  | { type: 'LOGIN_FAILURE' }
  | { type: 'LOGOUT' }

const authReducer = (state: AuthState, action: AuthAction): AuthState => {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, isLoading: true }
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isLoading: false
      }
    case 'LOGIN_FAILURE':
      return { ...state, user: null, token: null, isLoading: false }
    case 'LOGOUT':
      return { ...state, user: null, token: null }
    default:
      return state
  }
}

const AuthContext = createContext<{
  state: AuthState
  dispatch: React.Dispatch<AuthAction>
} | null>(null)

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, {
    user: null,
    token: localStorage.getItem('token'),
    isLoading: false
  })

  return (
    <AuthContext.Provider value={{ state, dispatch }}>
      {children}
    </AuthContext.Provider>
  )
}

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

## **Styling**

### **Tailwind CSS**
```typescript
// ✅ DO: Utility classes con Tailwind
import { cn } from '@/utils/cn'

interface CardProps {
  children: React.ReactNode
  className?: string
  variant?: 'default' | 'outlined' | 'elevated'
}

export const Card: React.FC<CardProps> = ({
  children,
  className,
  variant = 'default'
}) => {
  const baseClasses = 'rounded-lg p-6'
  
  const variantClasses = {
    default: 'bg-white shadow-sm border border-gray-200',
    outlined: 'bg-transparent border-2 border-gray-300',
    elevated: 'bg-white shadow-lg border border-gray-200'
  }

  return (
    <div className={cn(baseClasses, variantClasses[variant], className)}>
      {children}
    </div>
  )
}
```

### **CSS Modules (se necessario)**
```css
/* ✅ DO: CSS Modules per stili specifici */
.venueCard {
  @apply rounded-lg overflow-hidden shadow-md transition-transform hover:scale-105;
}

.venueCardImage {
  @apply w-full h-48 object-cover;
}

.venueCardContent {
  @apply p-4;
}

.venueCardTitle {
  @apply text-lg font-semibold text-gray-900 mb-2;
}

.venueCardDescription {
  @apply text-gray-600 text-sm;
}
```

## **Performance Optimization**

### **Memoization**
```typescript
// ✅ DO: Memoization per componenti costosi
import { memo, useMemo, useCallback } from 'react'

export const VenueList = memo<{ venues: Venue[]; onSelect: (venue: Venue) => void }>(
  ({ venues, onSelect }) => {
    const sortedVenues = useMemo(() => {
      return [...venues].sort((a, b) => a.name.localeCompare(b.name))
    }, [venues])

    const handleSelect = useCallback((venue: Venue) => {
      onSelect(venue)
    }, [onSelect])

    return (
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {sortedVenues.map((venue) => (
          <VenueCard
            key={venue.id}
            venue={venue}
            onSelect={handleSelect}
          />
        ))}
      </div>
    )
  }
)
```

### **Lazy Loading**
```typescript
// ✅ DO: Lazy loading per componenti pesanti
import { lazy, Suspense } from 'react'

const HeavyComponent = lazy(() => import('./HeavyComponent'))

export const LazyWrapper: React.FC = () => {
  return (
    <Suspense fallback={<div>Caricamento...</div>}>
      <HeavyComponent />
    </Suspense>
  )
}
```

## **Error Handling**

### **Error Boundaries**
```typescript
// ✅ DO: Error boundaries per gestione errori
import { Component, ReactNode } from 'react'

interface ErrorBoundaryState {
  hasError: boolean
  error?: Error
}

interface ErrorBoundaryProps {
  children: ReactNode
  fallback?: ReactNode
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="p-4 text-center">
          <h2 className="text-xl font-semibold text-red-600">Qualcosa è andato storto</h2>
          <p className="text-gray-600 mt-2">Ricarica la pagina per riprovare</p>
        </div>
      )
    }

    return this.props.children
  }
}
```

## **Testing**

### **Component Testing**
```typescript
// ✅ DO: Test componenti con React Testing Library
import { render, screen, fireEvent } from '@testing-library/react'
import { VenueCard } from './VenueCard'

const mockVenue = {
  id: '1',
  name: 'Test Venue',
  description: 'Test description',
  mainImage: 'test.jpg'
}

describe('VenueCard', () => {
  it('renders venue information correctly', () => {
    render(<VenueCard venue={mockVenue} />)
    
    expect(screen.getByText('Test Venue')).toBeInTheDocument()
    expect(screen.getByText('Test description')).toBeInTheDocument()
    expect(screen.getByAltText('Test Venue')).toHaveAttribute('src', 'test.jpg')
  })

  it('calls onSelect when clicked', () => {
    const onSelect = jest.fn()
    render(<VenueCard venue={mockVenue} onSelect={onSelect} />)
    
    fireEvent.click(screen.getByRole('button'))
    expect(onSelect).toHaveBeenCalledWith(mockVenue)
  })
})
```

## **Best Practices**

### **DO's**
- ✅ **Usare TypeScript** per type safety
- ✅ **Componenti funzionali** con hooks
- ✅ **Lazy loading** per performance
- ✅ **Error boundaries** per gestione errori
- ✅ **React Query** per data fetching
- ✅ **React Hook Form** per form management
- ✅ **Tailwind CSS** per styling
- ✅ **Memoization** per componenti costosi

### **DON'Ts**
- ❌ **Non usare class components** (tranne per error boundaries)
- ❌ **Non fare prop drilling** eccessivo
- ❌ **Non dimenticare cleanup** in useEffect
- ❌ **Non usare inline styles** quando possibile
- ❌ **Non dimenticare error handling** in async operations
- ❌ **Non usare index come key** in liste